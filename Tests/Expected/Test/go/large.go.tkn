{language.go:Kadet\Highlighter\Parser\Token\LanguageToken}{comment:Kadet\Highlighter\Parser\Token\Token}// Code generated by protoc-gen-gogo.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// source: api.proto{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// DO NOT EDIT!{/comment:Kadet\Highlighter\Parser\Token\Token}

{comment:Kadet\Highlighter\Parser\Token\Token}/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		api.proto
		config.proto
		data.proto
		errors.proto
		gossip.proto
		heartbeat.proto
		internal.proto

	It has these top-level messages:
		ClientCmdID
		RequestHeader
		ResponseHeader
		ContainsRequest
		ContainsResponse
		GetRequest
		GetResponse
		PutRequest
		PutResponse
		ConditionalPutRequest
		ConditionalPutResponse
		IncrementRequest
		IncrementResponse
		DeleteRequest
		DeleteResponse
		DeleteRangeRequest
		DeleteRangeResponse
		ScanRequest
		ScanResponse
		EndTransactionRequest
		EndTransactionResponse
		ReapQueueRequest
		ReapQueueResponse
		EnqueueUpdateRequest
		EnqueueUpdateResponse
		EnqueueMessageRequest
		EnqueueMessageResponse
		RequestUnion
		ResponseUnion
		BatchRequest
		BatchResponse
		AdminSplitRequest
		AdminSplitResponse
		AdminMergeRequest
		AdminMergeResponse
*/{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}package{/keyword:Kadet\Highlighter\Parser\Token\Token} proto

{keyword:Kadet\Highlighter\Parser\Token\Token}import{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1 {string.double:Kadet\Highlighter\Parser\Token\ContextualToken}"github.com/gogo/protobuf/proto"{/string.double:Kadet\Highlighter\Parser\Token\ContextualToken}
{keyword:Kadet\Highlighter\Parser\Token\Token}import{/keyword:Kadet\Highlighter\Parser\Token\Token} math {string.double:Kadet\Highlighter\Parser\Token\ContextualToken}"math"{/string.double:Kadet\Highlighter\Parser\Token\ContextualToken}

{comment:Kadet\Highlighter\Parser\Token\Token}// discarding unused import gogoproto "github.com/gogo/protobuf/gogoproto/gogo.pb"{/comment:Kadet\Highlighter\Parser\Token\Token}

{comment:Kadet\Highlighter\Parser\Token\Token}// Reference imports to suppress errors if they are not otherwise used.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}var{/keyword:Kadet\Highlighter\Parser\Token\Token} _ {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} proto1.Marshal
{keyword:Kadet\Highlighter\Parser\Token\Token}var{/keyword:Kadet\Highlighter\Parser\Token\Token} _ {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} math.Inf

{comment:Kadet\Highlighter\Parser\Token\Token}// ClientCmdID provides a unique ID for client commands. Clients which{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// provide ClientCmdID gain operation idempotence. In other words,{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// clients can submit the same command multiple times and always{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// receive the same response. This is common on retries over flaky{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// networks. However, the system imposes a limit on how long{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// idempotence is provided. Retries over an hour old are not{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// guaranteed idempotence and may be executed more than once with{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// potentially different results.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}//{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// ClientCmdID contains the client's timestamp and a client-generated{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// random number. The client Timestamp is specified in unix{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// nanoseconds and is used for some uniqueness but also to provide a{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// rough ordering of requests, useful for data locality on the{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// server. The Random is specified for additional uniqueness.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// NOTE: An accurate time signal IS NOT required for correctness.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}ClientCmdID{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	{comment:Kadet\Highlighter\Parser\Token\Token}// Nanoseconds since Unix epoch.{/comment:Kadet\Highlighter\Parser\Token\Token}
	WallTime         {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token}  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"varint,1,opt,name=wall_time" json:"wall_time"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Random           {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token}  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"varint,2,opt,name=random" json:"random"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ClientCmdID) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} ClientCmdID{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ClientCmdID) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*ClientCmdID) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ClientCmdID) {call:Kadet\Highlighter\Parser\Token\Token}GetWallTime{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.WallTime
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {number.integer:Kadet\Highlighter\Parser\Token\Token}0{/number.integer:Kadet\Highlighter\Parser\Token\Token}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ClientCmdID) {call:Kadet\Highlighter\Parser\Token\Token}GetRandom{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Random
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {number.integer:Kadet\Highlighter\Parser\Token\Token}0{/number.integer:Kadet\Highlighter\Parser\Token\Token}
}

{comment:Kadet\Highlighter\Parser\Token\Token}// RequestHeader is supplied with every storage node request.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}RequestHeader{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	{comment:Kadet\Highlighter\Parser\Token\Token}// Timestamp specifies time at which read or writes should be{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// performed. If the timestamp is set to zero value, its value{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// is initialized to the wall time of the receiving node.{/comment:Kadet\Highlighter\Parser\Token\Token}
	Timestamp Timestamp {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=timestamp" json:"timestamp"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// CmdID is optionally specified for request idempotence{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// (i.e. replay protection).{/comment:Kadet\Highlighter\Parser\Token\Token}
	CmdID ClientCmdID {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,opt,name=cmd_id" json:"cmd_id"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// The key for request. If the request operates on a range, this{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// represents the starting key for the range.{/comment:Kadet\Highlighter\Parser\Token\Token}
	Key Key {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,3,opt,name=key,customtype=Key" json:"key"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// End key is empty if request spans only a single key.{/comment:Kadet\Highlighter\Parser\Token\Token}
	EndKey Key {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,4,opt,name=end_key,customtype=Key" json:"end_key"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// User is the originating user. Used to lookup priority when{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// scheduling queued operations at target node.{/comment:Kadet\Highlighter\Parser\Token\Token}
	User {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,5,opt,name=user" json:"user"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// Replica specifies the destination for the request. This is a specific{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// instance of the available replicas belonging to RangeID.{/comment:Kadet\Highlighter\Parser\Token\Token}
	Replica Replica {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,6,opt,name=replica" json:"replica"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// RaftID specifies the ID of the Raft consensus group which the key{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// range belongs to. This is used by the receiving node to route the{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// request to the correct range.{/comment:Kadet\Highlighter\Parser\Token\Token}
	RaftID {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"varint,7,opt,name=raft_id" json:"raft_id"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// UserPriority specifies priority multiple for non-transactional{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// commands. This value should be a positive integer [1, 2^31-1).{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// It's properly viewed as a multiple for how likely this{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// transaction will be to prevail if a write conflict occurs.{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// Commands with UserPriority=100 will be 100x less likely to be{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// aborted as conflicting transactions or non-transactional commands{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// with UserPriority=1. This value is ignored if Txn is{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// specified. If neither this value nor Txn is specified, the value{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// defaults to 1.{/comment:Kadet\Highlighter\Parser\Token\Token}
	UserPriority {type:Kadet\Highlighter\Parser\Token\Token}*int32{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"varint,8,opt,name=user_priority,def=1" json:"user_priority,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// Txn is set non-nil if a transaction is underway. To start a txn,{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// the first request should set this field to non-nil with name and{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// isolation level set as desired. The response will contain the{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// fully-initialized transaction with txn ID, priority, initial{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// timestamp, and maximum timestamp.{/comment:Kadet\Highlighter\Parser\Token\Token}
	Txn              *Transaction {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,9,opt,name=txn" json:"txn,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token}       {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestHeader) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} RequestHeader{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestHeader) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*RequestHeader) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}const{/keyword:Kadet\Highlighter\Parser\Token\Token} Default_RequestHeader_UserPriority {type:Kadet\Highlighter\Parser\Token\Token}int32{/type:Kadet\Highlighter\Parser\Token\Token} {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} {number.integer:Kadet\Highlighter\Parser\Token\Token}1{/number.integer:Kadet\Highlighter\Parser\Token\Token}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestHeader) {call:Kadet\Highlighter\Parser\Token\Token}GetTimestamp{/call:Kadet\Highlighter\Parser\Token\Token}() Timestamp {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Timestamp
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} Timestamp{}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestHeader) {call:Kadet\Highlighter\Parser\Token\Token}GetCmdID{/call:Kadet\Highlighter\Parser\Token\Token}() ClientCmdID {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.CmdID
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} ClientCmdID{}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestHeader) {call:Kadet\Highlighter\Parser\Token\Token}GetUser{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.User
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {string.double:Kadet\Highlighter\Parser\Token\ContextualToken}""{/string.double:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestHeader) {call:Kadet\Highlighter\Parser\Token\Token}GetReplica{/call:Kadet\Highlighter\Parser\Token\Token}() Replica {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Replica
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} Replica{}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestHeader) {call:Kadet\Highlighter\Parser\Token\Token}GetRaftID{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.RaftID
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {number.integer:Kadet\Highlighter\Parser\Token\Token}0{/number.integer:Kadet\Highlighter\Parser\Token\Token}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestHeader) {call:Kadet\Highlighter\Parser\Token\Token}GetUserPriority{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}int32{/type:Kadet\Highlighter\Parser\Token\Token} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {operator:Kadet\Highlighter\Parser\Token\Token}&&{/operator:Kadet\Highlighter\Parser\Token\Token} m.UserPriority {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} *m.UserPriority
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} Default_RequestHeader_UserPriority
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestHeader) {call:Kadet\Highlighter\Parser\Token\Token}GetTxn{/call:Kadet\Highlighter\Parser\Token\Token}() *Transaction {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Txn
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{comment:Kadet\Highlighter\Parser\Token\Token}// ResponseHeader is returned with every storage node response.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}ResponseHeader{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	{comment:Kadet\Highlighter\Parser\Token\Token}// Error is non-nil if an error occurred.{/comment:Kadet\Highlighter\Parser\Token\Token}
	Error *Error {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// Timestamp specifies time at which read or write actually was{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// performed. In the case of both reads and writes, if the timestamp{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// supplied to the request was 0, the wall time of the node{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// servicing the request will be set here. Additionally, in the case{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// of writes, this value may be increased from the timestamp passed{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// with the RequestHeader if the key being written was either read{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// or written more recently.{/comment:Kadet\Highlighter\Parser\Token\Token}
	Timestamp Timestamp {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// Transaction is non-nil if the request specified a non-nil{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// transaction. The transaction timestamp and/or priority may have{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// been updated, depending on the outcome of the request.{/comment:Kadet\Highlighter\Parser\Token\Token}
	Txn              *Transaction {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,3,opt,name=txn" json:"txn,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token}       {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseHeader) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} ResponseHeader{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseHeader) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*ResponseHeader) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseHeader) {call:Kadet\Highlighter\Parser\Token\Token}GetError{/call:Kadet\Highlighter\Parser\Token\Token}() *Error {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Error
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseHeader) {call:Kadet\Highlighter\Parser\Token\Token}GetTimestamp{/call:Kadet\Highlighter\Parser\Token\Token}() Timestamp {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Timestamp
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} Timestamp{}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseHeader) {call:Kadet\Highlighter\Parser\Token\Token}GetTxn{/call:Kadet\Highlighter\Parser\Token\Token}() *Transaction {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Txn
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A ContainsRequest is arguments to the Contains() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}ContainsRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader    {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ContainsRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} ContainsRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ContainsRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*ContainsRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{comment:Kadet\Highlighter\Parser\Token\Token}// A ContainsResponse is the return value of the Contains() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}ContainsResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader   {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Exists           bool   {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"varint,2,opt,name=exists" json:"exists"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ContainsResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} ContainsResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ContainsResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*ContainsResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ContainsResponse) {call:Kadet\Highlighter\Parser\Token\Token}GetExists{/call:Kadet\Highlighter\Parser\Token\Token}() bool {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Exists
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {constant.special:Kadet\Highlighter\Parser\Token\Token}false{/constant.special:Kadet\Highlighter\Parser\Token\Token}
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A GetRequest is arguments to the Get() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}GetRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader    {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *GetRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} GetRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *GetRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*GetRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{comment:Kadet\Highlighter\Parser\Token\Token}// A GetResponse is the return value from the Get() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// If the key doesn't exist, returns nil for Value.Bytes.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}GetResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader   {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Value            *Value {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *GetResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} GetResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *GetResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*GetResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *GetResponse) {call:Kadet\Highlighter\Parser\Token\Token}GetValue{/call:Kadet\Highlighter\Parser\Token\Token}() *Value {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Value
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A PutRequest is arguments to the Put() method. Note that to write{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// an empty value, the value parameter is still specified, but both{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// Bytes and Integer are set to nil.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}PutRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader    {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Value            Value  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,opt,name=value" json:"value"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *PutRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} PutRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *PutRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*PutRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *PutRequest) {call:Kadet\Highlighter\Parser\Token\Token}GetValue{/call:Kadet\Highlighter\Parser\Token\Token}() Value {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Value
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} Value{}
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A PutResponse is the return value from the Put() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}PutResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader   {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *PutResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} PutResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *PutResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*PutResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{comment:Kadet\Highlighter\Parser\Token\Token}// A ConditionalPutRequest is arguments to the ConditionalPut() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}//{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// - Returns true and sets value if ExpValue equals existing value.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// - If key doesn't exist and ExpValue is nil, sets value.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// - If key exists, but value is empty and ExpValue is not nil but empty, sets value.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// - Otherwise, returns error and the actual value of the key in the response.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}ConditionalPutRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// The value to put.{/comment:Kadet\Highlighter\Parser\Token\Token}
	Value Value {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,opt,name=value" json:"value"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// ExpValue.Bytes empty to test for non-existence. Specify as nil{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// to indicate there should be no existing entry. This is different{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// from the expectation that the value exists but is empty.{/comment:Kadet\Highlighter\Parser\Token\Token}
	ExpValue         *Value {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,3,opt,name=exp_value" json:"exp_value,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ConditionalPutRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} ConditionalPutRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ConditionalPutRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*ConditionalPutRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ConditionalPutRequest) {call:Kadet\Highlighter\Parser\Token\Token}GetValue{/call:Kadet\Highlighter\Parser\Token\Token}() Value {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Value
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} Value{}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ConditionalPutRequest) {call:Kadet\Highlighter\Parser\Token\Token}GetExpValue{/call:Kadet\Highlighter\Parser\Token\Token}() *Value {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.ExpValue
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A ConditionalPutResponse is the return value from the{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// ConditionalPut() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}ConditionalPutResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader   {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ConditionalPutResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} ConditionalPutResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ConditionalPutResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*ConditionalPutResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{comment:Kadet\Highlighter\Parser\Token\Token}// An IncrementRequest is arguments to the Increment() method. It{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// increments the value for key, and returns the new value. If no{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// value exists for a key, incrementing by 0 is not a noop, but will{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// create a zero value. IncrementRequest cannot be called on a key set{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// by Put() or ConditionalPut(). Similarly, Get(), Put() and{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// ConditionalPut() cannot be invoked on an incremented key.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}IncrementRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader    {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Increment        {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token}  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"varint,2,opt,name=increment" json:"increment"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *IncrementRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} IncrementRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *IncrementRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*IncrementRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *IncrementRequest) {call:Kadet\Highlighter\Parser\Token\Token}GetIncrement{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Increment
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {number.integer:Kadet\Highlighter\Parser\Token\Token}0{/number.integer:Kadet\Highlighter\Parser\Token\Token}
}

{comment:Kadet\Highlighter\Parser\Token\Token}// An IncrementResponse is the return value from the Increment{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// method. The new value after increment is specified in NewValue. If{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// the value could not be decoded as specified, Error will be set.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}IncrementResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader   {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	NewValue         {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token}  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"varint,2,opt,name=new_value" json:"new_value"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *IncrementResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} IncrementResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *IncrementResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*IncrementResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *IncrementResponse) {call:Kadet\Highlighter\Parser\Token\Token}GetNewValue{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.NewValue
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {number.integer:Kadet\Highlighter\Parser\Token\Token}0{/number.integer:Kadet\Highlighter\Parser\Token\Token}
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A DeleteRequest is arguments to the Delete() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}DeleteRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader    {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *DeleteRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} DeleteRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *DeleteRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*DeleteRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{comment:Kadet\Highlighter\Parser\Token\Token}// A DeleteResponse is the return value from the Delete() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}DeleteResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader   {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *DeleteResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} DeleteResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *DeleteResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*DeleteResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{comment:Kadet\Highlighter\Parser\Token\Token}// A DeleteRangeRequest is arguments to the DeleteRange method. It{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// specifies the range of keys to delete.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}DeleteRangeRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// If 0, *all* entries between Key (inclusive) and EndKey{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// (exclusive) are deleted. Must be >= 0{/comment:Kadet\Highlighter\Parser\Token\Token}
	MaxEntriesToDelete {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token}  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"varint,2,opt,name=max_entries_to_delete" json:"max_entries_to_delete"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized   []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *DeleteRangeRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} DeleteRangeRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *DeleteRangeRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*DeleteRangeRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *DeleteRangeRequest) {call:Kadet\Highlighter\Parser\Token\Token}GetMaxEntriesToDelete{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.MaxEntriesToDelete
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {number.integer:Kadet\Highlighter\Parser\Token\Token}0{/number.integer:Kadet\Highlighter\Parser\Token\Token}
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A DeleteRangeResponse is the return value from the DeleteRange(){/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}DeleteRangeResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// Number of entries removed.{/comment:Kadet\Highlighter\Parser\Token\Token}
	NumDeleted       {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token}  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"varint,2,opt,name=num_deleted" json:"num_deleted"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *DeleteRangeResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} DeleteRangeResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *DeleteRangeResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*DeleteRangeResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *DeleteRangeResponse) {call:Kadet\Highlighter\Parser\Token\Token}GetNumDeleted{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.NumDeleted
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {number.integer:Kadet\Highlighter\Parser\Token\Token}0{/number.integer:Kadet\Highlighter\Parser\Token\Token}
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A ScanRequest is arguments to the Scan() method. It specifies the{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// start and end keys for the scan and the maximum number of results.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}ScanRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// Must be > 0.{/comment:Kadet\Highlighter\Parser\Token\Token}
	MaxResults       {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token}  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"varint,2,opt,name=max_results" json:"max_results"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ScanRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} ScanRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ScanRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*ScanRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ScanRequest) {call:Kadet\Highlighter\Parser\Token\Token}GetMaxResults{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.MaxResults
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {number.integer:Kadet\Highlighter\Parser\Token\Token}0{/number.integer:Kadet\Highlighter\Parser\Token\Token}
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A ScanResponse is the return value from the Scan() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}ScanResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// Empty if no rows were scanned.{/comment:Kadet\Highlighter\Parser\Token\Token}
	Rows             []KeyValue {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,rep,name=rows" json:"rows"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token}     {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ScanResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} ScanResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ScanResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*ScanResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ScanResponse) {call:Kadet\Highlighter\Parser\Token\Token}GetRows{/call:Kadet\Highlighter\Parser\Token\Token}() []KeyValue {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Rows
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{comment:Kadet\Highlighter\Parser\Token\Token}// An EndTransactionRequest is arguments to the EndTransaction() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// It specifies whether to commit or roll back an extant transaction.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}EndTransactionRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// False to abort and rollback.{/comment:Kadet\Highlighter\Parser\Token\Token}
	Commit bool {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"varint,2,opt,name=commit" json:"commit"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// Optional commit triggers. Note that commit triggers are for{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// internal use only and will be ignored if requested through the{/comment:Kadet\Highlighter\Parser\Token\Token}
	{comment:Kadet\Highlighter\Parser\Token\Token}// public-facing KV API.{/comment:Kadet\Highlighter\Parser\Token\Token}
	SplitTrigger     *SplitTrigger {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,3,opt,name=split_trigger" json:"split_trigger,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	MergeTrigger     *MergeTrigger {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,4,opt,name=merge_trigger" json:"merge_trigger,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token}        {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EndTransactionRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} EndTransactionRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EndTransactionRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*EndTransactionRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EndTransactionRequest) {call:Kadet\Highlighter\Parser\Token\Token}GetCommit{/call:Kadet\Highlighter\Parser\Token\Token}() bool {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Commit
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {constant.special:Kadet\Highlighter\Parser\Token\Token}false{/constant.special:Kadet\Highlighter\Parser\Token\Token}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EndTransactionRequest) {call:Kadet\Highlighter\Parser\Token\Token}GetSplitTrigger{/call:Kadet\Highlighter\Parser\Token\Token}() *SplitTrigger {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.SplitTrigger
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EndTransactionRequest) {call:Kadet\Highlighter\Parser\Token\Token}GetMergeTrigger{/call:Kadet\Highlighter\Parser\Token\Token}() *MergeTrigger {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.MergeTrigger
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{comment:Kadet\Highlighter\Parser\Token\Token}// An EndTransactionResponse is the return value from the{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// EndTransaction() method. The final transaction record is returned{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// as part of the response header. In particular, transaction status{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// and timestamp will be updated to reflect final committed{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// values. Clients may propagate the transaction timestamp as the{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// final txn commit timestamp in order to preserve causal ordering{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// between subsequent transactions. CommitWait specifies the commit{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// wait, which is the remaining time the client MUST wait before{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// signalling completion of the transaction to another distributed{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// node to maintain consistency.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}EndTransactionResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// Remaining time (ns).{/comment:Kadet\Highlighter\Parser\Token\Token}
	CommitWait       {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token}  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"varint,2,opt,name=commit_wait" json:"commit_wait"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EndTransactionResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} EndTransactionResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EndTransactionResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*EndTransactionResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EndTransactionResponse) {call:Kadet\Highlighter\Parser\Token\Token}GetCommitWait{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.CommitWait
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {number.integer:Kadet\Highlighter\Parser\Token\Token}0{/number.integer:Kadet\Highlighter\Parser\Token\Token}
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A ReapQueueRequest is arguments to the ReapQueue() method. It{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// specifies the recipient inbox key to which messages are waiting{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// to be reapted and also the maximum number of results to return.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}ReapQueueRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// Maximum results to return; must be > 0.{/comment:Kadet\Highlighter\Parser\Token\Token}
	MaxResults       {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token}  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"varint,2,opt,name=max_results" json:"max_results"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ReapQueueRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} ReapQueueRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ReapQueueRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*ReapQueueRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ReapQueueRequest) {call:Kadet\Highlighter\Parser\Token\Token}GetMaxResults{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}int64{/type:Kadet\Highlighter\Parser\Token\Token} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.MaxResults
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {number.integer:Kadet\Highlighter\Parser\Token\Token}0{/number.integer:Kadet\Highlighter\Parser\Token\Token}
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A ReapQueueResponse is the return value from the ReapQueue() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}ReapQueueResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader   {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Messages         []Value {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,rep,name=messages" json:"messages"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token}  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ReapQueueResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} ReapQueueResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ReapQueueResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*ReapQueueResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ReapQueueResponse) {call:Kadet\Highlighter\Parser\Token\Token}GetMessages{/call:Kadet\Highlighter\Parser\Token\Token}() []Value {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Messages
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{comment:Kadet\Highlighter\Parser\Token\Token}// An EnqueueUpdateRequest is arguments to the EnqueueUpdate() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// It specifies the update to enqueue for asynchronous execution.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// Update is an instance of one of the following messages: PutRequest,{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// IncrementRequest, DeleteRequest, DeleteRangeRequest, or{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// AccountingRequest.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}EnqueueUpdateRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader    {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EnqueueUpdateRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} EnqueueUpdateRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EnqueueUpdateRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*EnqueueUpdateRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{comment:Kadet\Highlighter\Parser\Token\Token}// An EnqueueUpdateResponse is the return value from the{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// EnqueueUpdate() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}EnqueueUpdateResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader   {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EnqueueUpdateResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} EnqueueUpdateResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EnqueueUpdateResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*EnqueueUpdateResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{comment:Kadet\Highlighter\Parser\Token\Token}// An EnqueueMessageRequest is arguments to the EnqueueMessage() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// It specifies the recipient inbox key and the message (an arbitrary{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// byte slice value).{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}EnqueueMessageRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	{comment:Kadet\Highlighter\Parser\Token\Token}// Message value to delivery to inbox.{/comment:Kadet\Highlighter\Parser\Token\Token}
	Msg              Value  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,opt,name=msg" json:"msg"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EnqueueMessageRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} EnqueueMessageRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EnqueueMessageRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*EnqueueMessageRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EnqueueMessageRequest) {call:Kadet\Highlighter\Parser\Token\Token}GetMsg{/call:Kadet\Highlighter\Parser\Token\Token}() Value {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Msg
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} Value{}
}

{comment:Kadet\Highlighter\Parser\Token\Token}// An EnqueueMessageResponse is the return value from the{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// EnqueueMessage() method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}EnqueueMessageResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader   {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EnqueueMessageResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} EnqueueMessageResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *EnqueueMessageResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*EnqueueMessageResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{comment:Kadet\Highlighter\Parser\Token\Token}// A RequestUnion contains exactly one of the optional requests.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}RequestUnion{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	Contains         *ContainsRequest       {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=contains" json:"contains,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Get              *GetRequest            {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,opt,name=get" json:"get,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Put              *PutRequest            {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,3,opt,name=put" json:"put,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	ConditionalPut   *ConditionalPutRequest {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,4,opt,name=conditional_put" json:"conditional_put,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Increment        *IncrementRequest      {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,5,opt,name=increment" json:"increment,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Delete           *DeleteRequest         {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,6,opt,name=delete" json:"delete,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	DeleteRange      *DeleteRangeRequest    {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,7,opt,name=delete_range" json:"delete_range,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Scan             *ScanRequest           {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,8,opt,name=scan" json:"scan,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	EndTransaction   *EndTransactionRequest {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,9,opt,name=end_transaction" json:"end_transaction,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	ReapQueue        *ReapQueueRequest      {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,10,opt,name=reap_queue" json:"reap_queue,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	EnqueueUpdate    *EnqueueUpdateRequest  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,11,opt,name=enqueue_update" json:"enqueue_update,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	EnqueueMessage   *EnqueueMessageRequest {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,12,opt,name=enqueue_message" json:"enqueue_message,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token}                 {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} RequestUnion{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetContains{/call:Kadet\Highlighter\Parser\Token\Token}() *ContainsRequest {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Contains
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetGet{/call:Kadet\Highlighter\Parser\Token\Token}() *GetRequest {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Get
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetPut{/call:Kadet\Highlighter\Parser\Token\Token}() *PutRequest {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Put
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetConditionalPut{/call:Kadet\Highlighter\Parser\Token\Token}() *ConditionalPutRequest {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.ConditionalPut
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetIncrement{/call:Kadet\Highlighter\Parser\Token\Token}() *IncrementRequest {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Increment
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetDelete{/call:Kadet\Highlighter\Parser\Token\Token}() *DeleteRequest {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Delete
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetDeleteRange{/call:Kadet\Highlighter\Parser\Token\Token}() *DeleteRangeRequest {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.DeleteRange
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetScan{/call:Kadet\Highlighter\Parser\Token\Token}() *ScanRequest {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Scan
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetEndTransaction{/call:Kadet\Highlighter\Parser\Token\Token}() *EndTransactionRequest {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.EndTransaction
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetReapQueue{/call:Kadet\Highlighter\Parser\Token\Token}() *ReapQueueRequest {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.ReapQueue
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetEnqueueUpdate{/call:Kadet\Highlighter\Parser\Token\Token}() *EnqueueUpdateRequest {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.EnqueueUpdate
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetEnqueueMessage{/call:Kadet\Highlighter\Parser\Token\Token}() *EnqueueMessageRequest {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.EnqueueMessage
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A ResponseUnion contains exactly one of the optional responses.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}ResponseUnion{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	Contains         *ContainsResponse       {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=contains" json:"contains,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Get              *GetResponse            {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,opt,name=get" json:"get,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Put              *PutResponse            {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,3,opt,name=put" json:"put,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	ConditionalPut   *ConditionalPutResponse {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,4,opt,name=conditional_put" json:"conditional_put,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Increment        *IncrementResponse      {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,5,opt,name=increment" json:"increment,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Delete           *DeleteResponse         {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,6,opt,name=delete" json:"delete,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	DeleteRange      *DeleteRangeResponse    {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,7,opt,name=delete_range" json:"delete_range,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Scan             *ScanResponse           {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,8,opt,name=scan" json:"scan,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	EndTransaction   *EndTransactionResponse {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,9,opt,name=end_transaction" json:"end_transaction,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	ReapQueue        *ReapQueueResponse      {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,10,opt,name=reap_queue" json:"reap_queue,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	EnqueueUpdate    *EnqueueUpdateResponse  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,11,opt,name=enqueue_update" json:"enqueue_update,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	EnqueueMessage   *EnqueueMessageResponse {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,12,opt,name=enqueue_message" json:"enqueue_message,omitempty"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token}                  {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} ResponseUnion{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetContains{/call:Kadet\Highlighter\Parser\Token\Token}() *ContainsResponse {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Contains
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetGet{/call:Kadet\Highlighter\Parser\Token\Token}() *GetResponse {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Get
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetPut{/call:Kadet\Highlighter\Parser\Token\Token}() *PutResponse {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Put
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetConditionalPut{/call:Kadet\Highlighter\Parser\Token\Token}() *ConditionalPutResponse {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.ConditionalPut
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetIncrement{/call:Kadet\Highlighter\Parser\Token\Token}() *IncrementResponse {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Increment
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetDelete{/call:Kadet\Highlighter\Parser\Token\Token}() *DeleteResponse {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Delete
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetDeleteRange{/call:Kadet\Highlighter\Parser\Token\Token}() *DeleteRangeResponse {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.DeleteRange
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetScan{/call:Kadet\Highlighter\Parser\Token\Token}() *ScanResponse {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Scan
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetEndTransaction{/call:Kadet\Highlighter\Parser\Token\Token}() *EndTransactionResponse {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.EndTransaction
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetReapQueue{/call:Kadet\Highlighter\Parser\Token\Token}() *ReapQueueResponse {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.ReapQueue
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetEnqueueUpdate{/call:Kadet\Highlighter\Parser\Token\Token}() *EnqueueUpdateResponse {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.EnqueueUpdate
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetEnqueueMessage{/call:Kadet\Highlighter\Parser\Token\Token}() *EnqueueMessageResponse {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.EnqueueMessage
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A BatchRequest contains one or more requests to be executed in{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// parallel, or if applicable (based on write-only commands and{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// range-locality), as a single update.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}BatchRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader    {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Requests         []RequestUnion {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,rep,name=requests" json:"requests"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token}         {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *BatchRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} BatchRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *BatchRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*BatchRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *BatchRequest) {call:Kadet\Highlighter\Parser\Token\Token}GetRequests{/call:Kadet\Highlighter\Parser\Token\Token}() []RequestUnion {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Requests
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{comment:Kadet\Highlighter\Parser\Token\Token}// A BatchResponse contains one or more responses, one per request{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// corresponding to the requests in the matching BatchRequest. The{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// error in the response header is set to the first error from the{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// slice of responses, if applicable.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}BatchResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader   {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	Responses        []ResponseUnion {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,rep,name=responses" json:"responses"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token}          {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *BatchResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} BatchResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *BatchResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*BatchResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *BatchResponse) {call:Kadet\Highlighter\Parser\Token\Token}GetResponses{/call:Kadet\Highlighter\Parser\Token\Token}() []ResponseUnion {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.Responses
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{comment:Kadet\Highlighter\Parser\Token\Token}// An AdminSplitRequest is arguments to the AdminSplit() method. The{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// existing range which contains RequestHeader.Key is split by{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// split_key. If split_key is not specified, then this method will{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// determine a split key that is roughly halfway through the{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// range. The existing range is resized to cover only its start key to{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// the split key. The new range created by the split starts at the{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// split key and extends to the original range's end key. If split_key{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// is known, header.key should also be set to split_key.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}//{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// New range IDs for each of the split range's replica and a new Raft{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// ID are generated by the operation. Split requests are done in the{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// context of a distributed transaction which updates range addressing{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// records, range metadata and finally, provides a commit trigger to{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// update bookkeeping and instantiate the new range on commit.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}//{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// The new range contains range replicas located on the same stores;{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// no range data is moved during this operation. The split can be{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// thought of as a mostly logical operation, though some other{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// metadata (e.g. response cache and range stats must be copied or{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// recomputed).{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}AdminSplitRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader    {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	SplitKey         Key    {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,opt,name=split_key,customtype=Key" json:"split_key"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *AdminSplitRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} AdminSplitRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *AdminSplitRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*AdminSplitRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{comment:Kadet\Highlighter\Parser\Token\Token}// An AdminSplitResponse is the return value from the AdminSplit(){/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}AdminSplitResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader   {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *AdminSplitResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} AdminSplitResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *AdminSplitResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*AdminSplitResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{comment:Kadet\Highlighter\Parser\Token\Token}// An AdminMergeRequest is arguments to the AdminMerge() method. A{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// merge is always performed by calling AdminMerge on the range{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// that is subsuming the passed in subsumed_range. The ranges must{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// be consecutive in the key space, such that the end_key of the{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// subsuming range must match the start_key of the range being subsumed.{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// After the merge operation, the subsumed_range will no longer exist and{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// the subsuming range will now encompass all keys from its original{/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// start_key to the end_key of the subsumed_range.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}AdminMergeRequest{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	RequestHeader    {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	SubsumedRange    RangeDescriptor {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,2,opt,name=subsumed_range" json:"subsumed_range"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token}          {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *AdminMergeRequest) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} AdminMergeRequest{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *AdminMergeRequest) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*AdminMergeRequest) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *AdminMergeRequest) {call:Kadet\Highlighter\Parser\Token\Token}GetSubsumedRange{/call:Kadet\Highlighter\Parser\Token\Token}() RangeDescriptor {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} m {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} m.SubsumedRange
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} RangeDescriptor{}
}

{comment:Kadet\Highlighter\Parser\Token\Token}// An AdminMergeResponse is the return value from the AdminMerge(){/comment:Kadet\Highlighter\Parser\Token\Token}
{comment:Kadet\Highlighter\Parser\Token\Token}// method.{/comment:Kadet\Highlighter\Parser\Token\Token}
{keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.struct:Kadet\Highlighter\Parser\Token\Token}AdminMergeResponse{/symbol.struct:Kadet\Highlighter\Parser\Token\Token} {keyword:Kadet\Highlighter\Parser\Token\Token}struct{/keyword:Kadet\Highlighter\Parser\Token\Token} {
	ResponseHeader   {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
	XXX_unrecognized []{type:Kadet\Highlighter\Parser\Token\Token}byte{/type:Kadet\Highlighter\Parser\Token\Token} {string.single:Kadet\Highlighter\Parser\Token\ContextualToken}`json:"-"`{/string.single:Kadet\Highlighter\Parser\Token\ContextualToken}
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *AdminMergeResponse) {call:Kadet\Highlighter\Parser\Token\Token}Reset{/call:Kadet\Highlighter\Parser\Token\Token}()         { *m {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} AdminMergeResponse{} }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (m *AdminMergeResponse) {call:Kadet\Highlighter\Parser\Token\Token}String{/call:Kadet\Highlighter\Parser\Token\Token}() {type:Kadet\Highlighter\Parser\Token\Token}string{/type:Kadet\Highlighter\Parser\Token\Token} { {keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} proto1.{call:Kadet\Highlighter\Parser\Token\Token}CompactTextString{/call:Kadet\Highlighter\Parser\Token\Token}(m) }
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (*AdminMergeResponse) {call:Kadet\Highlighter\Parser\Token\Token}ProtoMessage{/call:Kadet\Highlighter\Parser\Token\Token}()    {}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} {symbol.function:Kadet\Highlighter\Parser\Token\Token}init{/symbol.function:Kadet\Highlighter\Parser\Token\Token}() {
}
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (this *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetValue{/call:Kadet\Highlighter\Parser\Token\Token}() {keyword:Kadet\Highlighter\Parser\Token\Token}interface{/keyword:Kadet\Highlighter\Parser\Token\Token}{} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Contains {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Contains
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Get {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Get
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Put {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Put
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.ConditionalPut {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.ConditionalPut
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Increment {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Increment
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Delete {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Delete
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.DeleteRange {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.DeleteRange
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Scan {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Scan
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.EndTransaction {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.EndTransaction
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.ReapQueue {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.ReapQueue
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.EnqueueUpdate {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.EnqueueUpdate
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.EnqueueMessage {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.EnqueueMessage
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (this *RequestUnion) {call:Kadet\Highlighter\Parser\Token\Token}SetValue{/call:Kadet\Highlighter\Parser\Token\Token}(value {keyword:Kadet\Highlighter\Parser\Token\Token}interface{/keyword:Kadet\Highlighter\Parser\Token\Token}{}) bool {
	{keyword:Kadet\Highlighter\Parser\Token\Token}switch{/keyword:Kadet\Highlighter\Parser\Token\Token} vt {operator:Kadet\Highlighter\Parser\Token\Token}:={/operator:Kadet\Highlighter\Parser\Token\Token} value.({keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token}) {
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *ContainsRequest:
		this.Contains {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *GetRequest:
		this.Get {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *PutRequest:
		this.Put {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *ConditionalPutRequest:
		this.ConditionalPut {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *IncrementRequest:
		this.Increment {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *DeleteRequest:
		this.Delete {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *DeleteRangeRequest:
		this.DeleteRange {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *ScanRequest:
		this.Scan {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *EndTransactionRequest:
		this.EndTransaction {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *ReapQueueRequest:
		this.ReapQueue {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *EnqueueUpdateRequest:
		this.EnqueueUpdate {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *EnqueueMessageRequest:
		this.EnqueueMessage {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}default{/keyword:Kadet\Highlighter\Parser\Token\Token}:
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {constant.special:Kadet\Highlighter\Parser\Token\Token}false{/constant.special:Kadet\Highlighter\Parser\Token\Token}
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {constant.special:Kadet\Highlighter\Parser\Token\Token}true{/constant.special:Kadet\Highlighter\Parser\Token\Token}
}
{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (this *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}GetValue{/call:Kadet\Highlighter\Parser\Token\Token}() {keyword:Kadet\Highlighter\Parser\Token\Token}interface{/keyword:Kadet\Highlighter\Parser\Token\Token}{} {
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Contains {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Contains
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Get {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Get
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Put {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Put
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.ConditionalPut {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.ConditionalPut
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Increment {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Increment
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Delete {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Delete
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.DeleteRange {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.DeleteRange
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Scan {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.Scan
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.EndTransaction {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.EndTransaction
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.ReapQueue {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.ReapQueue
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.EnqueueUpdate {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.EnqueueUpdate
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}if{/keyword:Kadet\Highlighter\Parser\Token\Token} this.EnqueueMessage {operator:Kadet\Highlighter\Parser\Token\Token}!={/operator:Kadet\Highlighter\Parser\Token\Token} nil {
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} this.EnqueueMessage
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} nil
}

{keyword:Kadet\Highlighter\Parser\Token\Token}func{/keyword:Kadet\Highlighter\Parser\Token\Token} (this *ResponseUnion) {call:Kadet\Highlighter\Parser\Token\Token}SetValue{/call:Kadet\Highlighter\Parser\Token\Token}(value {keyword:Kadet\Highlighter\Parser\Token\Token}interface{/keyword:Kadet\Highlighter\Parser\Token\Token}{}) bool {
	{keyword:Kadet\Highlighter\Parser\Token\Token}switch{/keyword:Kadet\Highlighter\Parser\Token\Token} vt {operator:Kadet\Highlighter\Parser\Token\Token}:={/operator:Kadet\Highlighter\Parser\Token\Token} value.({keyword:Kadet\Highlighter\Parser\Token\Token}type{/keyword:Kadet\Highlighter\Parser\Token\Token}) {
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *ContainsResponse:
		this.Contains {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *GetResponse:
		this.Get {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *PutResponse:
		this.Put {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *ConditionalPutResponse:
		this.ConditionalPut {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *IncrementResponse:
		this.Increment {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *DeleteResponse:
		this.Delete {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *DeleteRangeResponse:
		this.DeleteRange {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *ScanResponse:
		this.Scan {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *EndTransactionResponse:
		this.EndTransaction {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *ReapQueueResponse:
		this.ReapQueue {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *EnqueueUpdateResponse:
		this.EnqueueUpdate {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}case{/keyword:Kadet\Highlighter\Parser\Token\Token} *EnqueueMessageResponse:
		this.EnqueueMessage {operator:Kadet\Highlighter\Parser\Token\Token}={/operator:Kadet\Highlighter\Parser\Token\Token} vt
	{keyword:Kadet\Highlighter\Parser\Token\Token}default{/keyword:Kadet\Highlighter\Parser\Token\Token}:
		{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {constant.special:Kadet\Highlighter\Parser\Token\Token}false{/constant.special:Kadet\Highlighter\Parser\Token\Token}
	}
	{keyword:Kadet\Highlighter\Parser\Token\Token}return{/keyword:Kadet\Highlighter\Parser\Token\Token} {constant.special:Kadet\Highlighter\Parser\Token\Token}true{/constant.special:Kadet\Highlighter\Parser\Token\Token}
}
{/language.go:Kadet\Highlighter\Parser\Token\LanguageToken}